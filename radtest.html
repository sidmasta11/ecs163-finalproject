<!DOCTYPE html>
<meta charset="utf-8">
<style>

.frame {
  fill: none;
  stroke: #000;
}

.axis text {
  font: 10px sans-serif;
}

.axis line,
.axis circle {
  fill: none;
  stroke: #777;
  stroke-dasharray: 1,4;
}

.axis :last-of-type circle {
  stroke: #333;
  stroke-dasharray: none;
}

.line {
  fill: none;
  stroke: red;
  stroke-width: 1.5px;
}

</style>
<body>
<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCayptOHNc__lBNXDceFPO-zojv3culgX0&libraries=geometry&sensor=false"
  type="text/javascript"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
//<button id="back" type="button" onclick="ToggleFunc(-1)">Toggle Logarithmic Scaling</button><p>
//var data = d3.range(0.01, 2 * Math.PI, .001).map(function(t) {
  //return [t, Math.sin(2 * t) * Math.cos(2 * t)];
//});
var distMax = 5000
var massLo = 10
var massHi = 30000
var timeStart = 1990
var timeEnd = 2000

var color = d3.scaleOrdinal(d3.schemeCategory10);
var width = 960,
    height = 500,
    radius = Math.min(width, height) / 2 - 30;

var scaleIsLog = 1
var r = d3.scaleLog()
//var r = d3.scaleLinear()
    .domain([10, 5000])
    .range([0, radius]);

var line = d3.radialLine()
    .radius(function(d) { return r(d[1]); })
    .angle(function(d) { return -d[0] + Math.PI / 2; });

//svg.append("path")
//    .datum(data)
//    .attr("class", "line")
//    .attr("d", line);

function ToggleFunc(){
	if (scaleIsLog == 1) {
		scaleIsLog = 0
		r = d3.scaleLinear()
			.domain([10, 5000])
			.range([0, radius]);
		
	}
	else if (scaleIsLog == 0) {
		scaleIsLog = 1
		r = d3.scaleLog()
			.domain([10, 5000])
			.range([0, radius]);
	}
}

	
d3.csv("meteorite.csv", function(error, metData) {

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

var gr = svg.append("g")
    .attr("class", "r axis")
  .selectAll("g")
    .data(r.ticks(5).slice(0))
  .enter().append("g");

gr.append("circle")
    .attr("r", r);

gr.append("text")
    .attr("y", function(d) { return -r(d) - 4; })
    .attr("transform", "rotate(0)")
    .style("text-anchor", "middle")
    .text(function(d) { return d; });

var ga = svg.append("g")
    .attr("class", "a axis")
  .selectAll("g")
    .data(d3.range(0, 360, 90))
  .enter().append("g")
    .attr("transform", function(d) { return "rotate(" + -d + ")"; });

ga.append("line")
    .attr("x2", radius);

ga.append("text")
    .attr("x", radius + 6)
    .attr("dy", ".35em")
    .style("text-anchor", function(d) { return d < 270 && d > 90 ? "end" : null; })
    .attr("transform", function(d) { return d < 270 && d > 90 ? "rotate(180 " + (radius + 6) + ",0)" : null; })
    .text(function(d) { if (d == 90) 
							return "N"
						else if (d==0)
							return "E"
						else if (d==180)
							return "W" 
						else if (d==270)
							return "S" });


	var data2 = [];
	var OriginLatLng = new google.maps.LatLng({lat: 38.5449, lng: -121.7405});
	var dist = 0;
	var bearing = 0;
	
	var stateList = [];
//	data.forEach(function(d){ 

	var i
	for (i = 1; i < 19969; i ++) {   //capping loop to avoid 32k Api calls while testing.
		var d=metData[i]
		if (d['mass (g)'] <= massHi && d['mass (g)'] >= massLo && d['year'] <= timeEnd && d['year'] >= timeStart) {
			
			var myLatLng = new google.maps.LatLng({lat: +d['reclat'], lng: +d['reclong']});
			dist = google.maps.geometry.spherical.computeDistanceBetween(OriginLatLng, myLatLng);
			if (dist < 10000) {dist = 10000}
			if (dist < distMax*1000) {
					bearing = google.maps.geometry.spherical.computeHeading(OriginLatLng, myLatLng);
					data2 = data2.concat([[((450-bearing)*(Math.PI/180)), (dist/1000), d['mass (g)'], d['recclass']]])
			}
		}
	}
	
		svg.selectAll("point")
      .data(data2)
      .enter()
      .append("circle")
      .attr("class", "point")
      .attr("transform", function(d) {
        var coors = line([d]).slice(1).slice(0, -1);
        return "translate(" + coors + ")"
      })
      .attr("r", function(d) {
		if (d[2] < 100) {return 2}
		if (d[2] < 1000) {return 4}
		if (d[2] < 10000) {return 8}
		return 12
	  })
      .attr("fill",function(d,i){
		console.log(d[3])
		console.log(d[3].charAt(0))
		if (d[3].charAt(0) == 'A') {return color(1)}
		if (d[3].charAt(0) == 'C') {return color(2)}
		if (d[3].charAt(0) == 'D') {return color(3)}
		if (d[3].charAt(0) == 'E') {return color(4)}
		if (d[3].charAt(0) == 'H') {return color(5)}
		if (d[3].charAt(0) == 'I') {return color(6)}
		if (d[3].charAt(0) == 'L') {return color(7)}
		if (d[3].charAt(0) == 'M') {return color(8)}
		if (d[3].charAt(0) == 'R') {return color(9)}
		return color(10)
      })
	  .attr("stroke", "black")
	  .append('title') // Tooltip
        .text(function (d) { return  "Bearing: " +  (450-d[0]/(Math.PI/180)).toFixed(2) + ", Distance: " + Math.round(d[1]) + "km, Mass: "+ d[2]+"g, Class: " + d[3]});

	//})

});
		
	
	
</script>

