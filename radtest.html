<!DOCTYPE html>
<meta charset="utf-8">
<style>

.frame {
  fill: none;
  stroke: #000;
}

.axis text {
  font: 10px sans-serif;
}

.axis line,
.axis circle {
  fill: none;
  stroke: #777;
  stroke-dasharray: 1,4;
}

.axis :last-of-type circle {
  stroke: #333;
  stroke-dasharray: none;
}

.line {
  fill: none;
  stroke: red;
  stroke-width: 1.5px;
}

</style>
<body>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>
//<button id="back" type="button" onclick="ToggleFunc(-1)">Toggle Logarithmic Scaling</button><p>
//var data = d3.range(0.01, 2 * Math.PI, .001).map(function(t) {
  //return [t, Math.sin(2 * t) * Math.cos(2 * t)];
//});




var color = d3.scaleOrdinal(d3.schemeCategory20);
var width = 960,
    height = 500,
    radius = Math.min(width, height) / 2 - 30;

var scaleIsLog = 1
var r = d3.scaleLog()
//var r = d3.scaleLinear()
    .domain([10, 20000])
    .range([0, radius]);

var line = d3.radialLine()
    .radius(function(d) { return r(d[1]); })
    .angle(function(d) { return -d[0] + Math.PI / 2; });


//svg.append("path")
//    .datum(data)
//    .attr("class", "line")
//    .attr("d", line);

function ToggleFunc(){
	if (scaleIsLog == 1) {
		scaleIsLog = 0
		r = d3.scaleLinear()
			.domain([10, 20000])
			.range([0, radius]);
		
	}
	else if (scaleIsLog == 0) {
		scaleIsLog = 1
		r = d3.scaleLog()
			.domain([10, 20000])
			.range([0, radius]);
	}
}


	
d3.csv("meteorite.csv", function(error, metData) {

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
  .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

var gr = svg.append("g")
    .attr("class", "r axis")
  .selectAll("g")
    .data(r.ticks(5).slice(0))
  .enter().append("g");

gr.append("circle")
    .attr("r", r);

gr.append("text")
    .attr("y", function(d) { return -r(d) - 4; })
    .attr("transform", "rotate(0)")
    .style("text-anchor", "middle")
    .text(function(d) { return d; });

var ga = svg.append("g")
    .attr("class", "a axis")
  .selectAll("g")
    .data(d3.range(0, 360, 90))
  .enter().append("g")
    .attr("transform", function(d) { return "rotate(" + -d + ")"; });

ga.append("line")
    .attr("x2", radius);

ga.append("text")
    .attr("x", radius + 6)
    .attr("dy", ".35em")
    .style("text-anchor", function(d) { return d < 270 && d > 90 ? "end" : null; })
    .attr("transform", function(d) { return d < 270 && d > 90 ? "rotate(180 " + (radius + 6) + ",0)" : null; })
    .text(function(d) { if (d == 90) 
							return "N"
						else if (d==0)
							return "E"
						else if (d==180)
							return "W" 
						else if (d==270)
							return "S" });


	var data2 = [];
	var OriginLatLng = new google.maps.LatLng({lat: 38.5449, lng: -121.7405});
	var dist = 0;
	var bearing = 0;
	
	var stateList = [];
//	data.forEach(function(d){ 


	var i
	for (i = 1; i < 320.00; i ++) {   //capping loop to avoid 32k Api calls while testing.
		var d=metData[i]
	
		var myLatLng = new google.maps.LatLng({lat: +d['reclat'], lng: +d['reclong']});
		dist = google.maps.geometry.spherical.computeDistanceBetween(OriginLatLng, myLatLng);
		bearing = google.maps.geometry.spherical.computeHeading(OriginLatLng, myLatLng);
		data2 = data2.concat([[((450-bearing)*(Math.PI/180)), (dist/1000)]])

	}
	
		svg.selectAll("point")
      .data(data2)
      .enter()
      .append("circle")
      .attr("class", "point")
      .attr("transform", function(d) {
        var coors = line([d]).slice(1).slice(0, -1);
        return "translate(" + coors + ")"
      })
      .attr("r", 8)
      .attr("fill",function(d,i){
        return color(i);
      })
	  .append('title') // Tooltip
        .text(function (d) { return  "Bearing: " +  (450-d[0]/(Math.PI/180)).toFixed(2) + " Distance: " + Math.round(d[1]) + "km" });


	
	
	
	

	//})

});
		
	
	
</script>
    <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD_5nzRzli7BUXYEw-cewiS1T8PJOC7o0k&libraries=geometry">
    </script>